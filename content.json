{"pages":[],"posts":[{"title":"electron-vue仿网易云音乐桌面应用","text":"简介像官网说的那样，electron-vue就是基于 vue 来构造 electron 应用程序的样板代码。electron-vue开发起来就和vue一样，只是如果有特殊的需求需要修改应用的话就要用到electron相关的api，项目中的数据来自这里，感谢大佬的分享。项目地址git地址 electronElectron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。(摘之官网) vuevue的话就不多提了，网站 预览 18/11/05更新项目流程可以先去electron官网了解一下它的开发流程，知道它大体是个怎样的情况就好，后面使用的时候可以再来看看它的api.搭建12345npm install -g vue-cli vue init simulatedgreg/electron-vue ele-vuecd ele-vuenpm installnpm run dev 安装过程中一路回车就行，中途会有个让你选择插件的时候，也是为了后面自己手动去装，这里就根据需要选择。 electron-packager如果你刚开始制作 electron 应用程序或只需要创建简单的可执行文件，那么 electron-packager 就可以满足你的需求。 electron-builder如果你正在寻找完整的安装程序、自动更新的支持、使用 Travis CI 和 AppVeyor 的 CI 构建、或本机 node 模块的自动重建，那么你会需要 electron-builder。 还是根据自己的需要选择这些完成以后就可以像开发vue一样去开发项目了。 插件方面electron-vue中也是能使用前端的ui组件的，以element-ui为例123456npm i element-ui -S然后在main.js中引入import ElementUI from &apos;element-ui&apos;;import &apos;element-ui/lib/theme-chalk/index.css&apos;;Vue.use(ElementUI); electron12345678一点自己的配置mainWindow = new BrowserWindow({ height: 670,//窗口高度 width: 1000,//窗口宽度 frame: true,//是否显示窗口边框 resizable: false,//可否缩放 movable: true//可否移动 }) iconfontelement的icon可能并不能满足我们的需求，这时候可以选择使用阿里的iconfont。先去iconfont官网选择你想要的icon， 选择添加到你自己的项目然后可以在自己的项目中选择生成，复制代码到electron-vue项目的index.ejs中，正常引用css&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_883876_bfzwywhpal.css&quot;&gt;使用&lt;i class=&quot;iconfont icon-play-circle&quot;&gt;&lt;/i&gt; 打包直接使用npm run build就可以打包，若是要针对不同平台则按需添加参数，打包后的安装包在项目的build文件夹下 最后界面是两天开发出来的。。所以某些样式不太美观。有个问题是打包以后iconfont不显示了，这个问题后面再解决一下，最直接的办法还是把它下到本地引用。","link":"/2018/12/10/electron-vue仿网易云音乐桌面应用/"},{"title":"vue3+egg仿掘金官网","text":"看了egg.js后突然就想搞个全栈的项目玩玩，又喜欢在掘金上逛，所以就开发了这个项目。虽说vue3.0还没定下来，但已经能用了，喜欢它的直接在网页上搞项目，所以就用了3。GIT地址预览地址有些地方用的假数据 已完成● 首页标签分类预览● 修改个人信息● 图片上传● 文章详情● 发布沸点 预览 18/12/19 18 文章详情1.0 18/12/20 11 文章详情2.0 18/12/21 10昨天把服务器弄好了http://134.175.224.127:8081/访问会很慢后面再慢慢弄，正好把域名也弄好 18/12/21 22 动态页面1.0 18/12/24 11 动态页面2.0 增加实时发布功能 项目包含 vue3.0 egg.js 腾讯云图片上传 项目搭建vue3.03的话可以向之前一样用命令行建项目，也可以用图形化界面来创建，我自己的话是用图形化界面建立的，这也是选择3的原因之一123456//安装npm install -g @vue/cli//查看版本vue --version//打开图形化界面vue ui 运行成功以后会跳转到 选择你要建立项目的磁盘路径，然后点击最下面的按钮，填写项目的基本信息 到下一步的话会让你选择一些项目依赖，如果是第一次建立的话，可以选择Manual然后选择需要的依赖 接下来会让你选择eslint的相关配置，虽然eslint有时候真的是太严格了，不过养成习惯以后就会很舒服了，而且这边提供了保存和提交时自动fix的功能，所以都选上 创建完成以后，可以点击右上方的按钮直接下载想要的插件，有时候甚至会直接帮你在项目中弄好引入，省了手动写一些引入的代码 最后就是可以直接在这边运行项目了 这些只是基本搭建到运行，还有很多功能可以自己去发发掘一下。 vue3.0配置跨域3的话需要自己手动在根目录下建立vue.config.js，内容的话还是和以前差不多的，这里贴上我的简单的跨域配置 egg.jsegg的话，官网写的还是挺详细的，跟着快速入门走一遍基本就差不多了。这里就贴上基本的连接mysql配置 腾讯云上传因为涉及图片上传的相关东西，所以使用了腾讯云。先去腾讯云首页添加对象存储然后创建存储桶 然后在基础设置中配置一下cors的白名单 注意这边的Expose-Headers，不设置的话到时候上传完以后的回调会没有url。 然后去这边把Secretid和SecretKey拿一下后面要用项目中使用：12345678910111213141516171819202122232425262728//安装一下npm install cos-js-sdk-v5 -S//在需要上传的文件中import COS from &quot;cos-js-sdk-v5&quot;;this.myCos = new COS({ SecretId: &quot;你的id&quot;, SecretKey: &quot;你的key&quot; }); //在获取到上传文件对象后this.myCos.putObject( { Bucket: &quot;你的存储桶空间名称&quot;, Region: &quot;你的存储桶所在地域&quot;, Key: e.target.files[0].name,//上传的文件名 StorageClass: &quot;STANDARD&quot;, Body: e.target.files[0], // 上传文件对象 onProgress: function(progressData) { self.user.avator = progressData.Location;//Location就是上传完成以后的对象路径 } }, function(err, data) { console.log(err || data); console.log(data.Location); } ); 服务器 购买云服务器 https://cloud.tencent.com/act/campus 加购域名(很便宜的那种几十块) 解析域名 可直接选 新手快速添加 登陆服务器配置环境安装wget yum install -y wget 安装nodewget https://nodejs.org/dist/v10.14.2/node-v10.14.2-darwin-x64.tar.gz解压 tar -xvf node-v10.14.2-darwin-x64.tar.gz重命名 mv node-v10.14.2-darwin-x64 node软连接(全局命令)ln -s ~/node/bin/node /usr/bin/nodeln -s ~/node/bin/npm /usr/bin/npmnode -v安装git yum –y install git安装jdk yum -y install javajava -version路径 /usr/lib/jvm安装tomacat yum -y install tomcatrpm -q tomcat路径 /usr/share/tomcat 5 环境变量 vi .bashrc 填入JAVA_HOME=/usr/lib/jvm/java PATH=$PATH:$JAVA_HOME/bin CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar CATALINA_BASE=/usr/share/tomcat CATALINA_HOME=/usr/share/tomcat export JAVA_HOME PATH CLASSPATH CATALINA_BASE CATALINA_HOME :wq保存以后 source .bashrc 将你的项目放到/usr/share/tomcat/webapps 下后启动tomcatsystemctl start tomcat.service查看lsof -i:8080 端口重定向iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-port 8080","link":"/2019/01/29/vue3-egg仿掘金官网/"},{"title":"mpvue微信小程序-仿网易云音乐","text":"前言在尝试开发了一个微信小程序之，后发现有mpvue这么个东西可以来开发小程序以后就忍不住了，所以把小程序和我用vue开发过的版本结合修改以后，再尝试用mpvue+iview-weapp开发一个版本。后台接口用的是NeteaseCloudMusicApi,感谢大佬的分享 git地址，demo项目代码质量不是很好，哈哈哈哈多多见谅😁 预览 项目搭建 最开始还是要把微信小程序开发工具下载一下 mpvue项目建立，跟着官网走一遍是最快的 快速上手 支持iview-weapp，还是跟着官网快速上手，这里就一个地方要注意，把下载下来的iview-weapp项目的dist文件夹（可以改名字）是放到你项目编译后的dist目录下，iview-weapp官网没有效果的展示，所以建议扫它上面的二维码查看效果以后对照它的代码进行开发 最后就是用微信小程序开发工具打开项目(不是dist目录)，用你常用的编译器编写代码（src目录下） 请求方面微信小程序有自带的wx.request()可以使用，还可以用Flyio，我是用的Flyio具体使用的话可以再每个模块中123var Fly=require(&quot;flyio/dist/npm/wx&quot;)var fly=new Flyfly.get(url).then(res=&gt;{}) 还有就是在main.js中12345const Fly = require(&apos;flyio/dist/npm/wx&apos;);let fly = new Fly();Vue.prototype.$fly = fly;//模块中使用 this.$fiy.get(url).then(res=&gt;{}) 路由跳转传参wx.navigateTo({url:’../test/main?id=’+id})第一种：12345onShow (options) {let id = options.id} 第二种：在所有页面组件内可以通过 this.$root.$mp.query 获取,要注意就是：写在mounted函数里，写到created报错。 第三种：在所有的组件内可以通过 this.$root.$mp.appOptions获取。正常情况下三种应该都是可以的，某一种没用的时候就尝试另外两种 vuex方面还是和vue里面的使用一样，简单的/src/store/store.js1234567891011121314151617181920import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;;Vue.use(Vuex);export default new Vuex.Store({ state: { oneState:&apos;one&apos; } }, mutations: { setItem: (state,data) =&gt; { state.oneState = data }, }, getters : { getItem (state) { return state.oneState },}); /src/main.js12import store from &apos;./store/store&apos;Vue.prototype.$store = store; /src/page/text.vue12345678910111213import {mapGetters} from &apos;vuex&apos; export default { computed:{ ...mapGetters([ &apos;oneState&apos; ]) }, }, methods:{ test(){ this.$store.commit(&apos;setItem&apos;, &apos;two&apos;) } } 总结好了，基本的开发流程就是这样，具体的开发大部分还是像vue开发那样，自己在开发的时候，遇到的坑还是有的，但网上基本都能找到解决方案，具体遇到的时候就查一查都能查到，收获很多，需要改进、优化、学习的也很多。最后这里还有一个用vue开发的版本可在线预览,建议用chrome的手机模式预览","link":"/2018/09/04/mpvue微信小程序-仿网易云音乐/"},{"title":"一些js代码","text":"统计数组中元素出现次数reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。 reducer 函数接收4个参数: 1.Accumulator (acc) (累计器) 2.Current Value (cur) (当前值) 3.Current Index (idx) (当前索引) 4.Source Array (src) (源数组) 您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。 12345const count = arr =&gt; arr.reduce((acc, val) =&gt; { acc[val] = (acc[val] || 0) + 1; return acc;},{})count([1,1,2,3,1,1,2]); // {1:4,2:2,3:1} 数组扁平化(完全)concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 123456const aryFlatten = arr =&gt; [].concat(...arr.map(v =&gt; Array.isArray(v) ? aryFlatten(v) :v))reduce版const aryFlatten = arr =&gt; arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? aryFlatten(v) : v),[])aryFlatten([1, [2], [[3], 4], 5]); // [1,2,3,4,5] 根据提供的层数扁平化123const flattenBy = (arr, depth=1) =&gt; arr.reduce((a, v) =&gt; a.concat(depth&gt;1 &amp;&amp; Array.isArray(v) ? flattenBy(v, depth-1) : v),[])flattenBy([1, [2, [3, [4, 5], 6], 7], 8], 2); // [1, 2, 3, [4, 5], 6, 7, 8] 去除数组中的所有假植123const filterFalsy = arr =&gt; arr.filter(Boolean)filterFalsy([&apos;&apos;, true, {}, false, &apos;sample&apos;, 1, 0]); // [true, {}, &apos;sample&apos;, 1] 获取指定值在数组中出现的所有下标123const indexOfAll = (arr, val) =&gt; arr.reduce((a, v, i) =&gt; v===val? [...a,i]: a,[])indexOfAll([1, 2, 3, 1, 2, 3], 1); // [0,3] 通过给定的结束值，开始值，步长生成数组Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。 Math.ceil 向上取整 1234567const initializeArrayWithRange = (end, start=0, step=1) =&gt; Array.from({length: Math.ceil(end-start+1)/step}, (v, i)=&gt; i*step+start)initializeArrayWithRange(5); // [0,1,2,3,4,5]initializeArrayWithRange(7, 3); // [3,4,5,6,7]initializeArrayWithRange(9, 0, 2); // [0,2,4,6,8] 获取两个数组的交集123456789const intersection = (a, b) =&gt; { const s = new Set(b) return a.filter(x =&gt; s.has(x))}或const intersection = (a, b) =&gt; a.filter(x =&gt; b.includes(a))intersection([1, 2, 3], [4, 3, 2]); // [2, 3] 打乱数组顺序12345678910const shuffle = arr =&gt;{ let m = arr.length; while(m){ let i = Math.floor(Math.random() * m--) [arr[i],arr[m]] = [arr[m],arr[i]] } return arr;}shuffle([1, 2, 3]); // [2, 3, 1] 根据提供的方法留下符合条件的123456789101112131415161718const uniqueElementsBy = (arr, fn) =&gt; arr.reduce((acc, val) =&gt; { !acc.some(x =&gt; fn(x,val))?acc.push(val):&apos;&apos; return acc; } ,[]) uniqueElementsBy([ { id: 0, value: &apos;a&apos; }, { id: 1, value: &apos;b&apos; }, { id: 2, value: &apos;c&apos; }, { id: 1, value: &apos;d&apos; }, { id: 0, value: &apos;e&apos; }],(a, b) =&gt; a.id == b.id);返回 [ { id: 0, value: &apos;a&apos; }, { id: 1, value: &apos;b&apos; }, { id: 2, value: &apos;c&apos; } ] 防抖12345678const debounce = (fn, ms=0)=&gt;{ let timer; return fn(...args){ clearTimeout(timer); timer = setTimeout(() =&gt; fn.bind(this,args),ms) }} 先立即执行一次再防抖12345678910111213141516const debounce = (fn, ms=0, immediate=true)=&gt;{ let timer; return function(...args){ if(timer) clearTimeout(timer) if(immediate){ fn() immediate=false }else{ timer = setTimeout(()=&gt;{ fn.apply(this,args) immediate=true },ms) } }} 斐波那契123const fb = (n) =&gt; Array.from({length:n+1}).reduce((acc,val,i) =&gt; (acc.concat(i&gt;1?acc[i-2]+acc[i-1]:i)),[]) 先立即执行一次再节流123456789101112131415161718192021const throttle = (fn, wait) =&gt; { let inThrottle, lastFn, lastTime; return function() { const context = this, args = arguments; if (!inThrottle) { fn.apply(context, args); lastTime = Date.now(); inThrottle = true; } else { clearTimeout(lastFn); lastFn = setTimeout(function() { if (Date.now() - lastTime &gt;= wait) { fn.apply(context, args); lastTime = Date.now(); } }, Math.max(wait - (Date.now() - lastTime), 0)); } };}; 只执行一次的方法123456789const once = fn =&gt; { let called = false; return fn(...args){ if(called) return; called = true; return fn.apply(this,...args) }} 生成指定范围内的n个随机数123const randomIntArrayInRange = (max, min, n) =&gt; Array.from({length:n},()=&gt; Math.floor(Math.random() * (max-min+1) + min))) 深拷贝123456789101112const deepClone = obj =&gt; {let clone = Object.assign({}, obj);Object.keys(clone).forEach( key =&gt; (clone[key] = typeof obj[key] === &apos;object&apos; ? deepClone(obj[key]) : obj[key]));return Array.isArray(obj) &amp;&amp; obj.length ? (clone.length = obj.length) &amp;&amp; Array.from(clone) : Array.isArray(obj) ? Array.from(obj) : clone;};","link":"/2019/02/28/一些js代码/"},{"title":"my-rss","text":"Izaya’rss数据来自rsshub官网，进行格式化以后使用vue+element呈现izaya’rss rss 汪志强的rss izayawwwGit地址 https://github.com/Izayawww/my-rss.git链接 https://izayawww.netlify.com/","link":"/2019/01/29/my-rss/"},{"title":"vue","text":"MVVM全称是Model-View-ViewModel； 1、M就是Model模型层，存的⼀个数据对象。 2、V就是View视图层，所有的html节点在这⼀层。 3、VM就是ViewModel，它通过data属性连接Model模型层，通过el属性连接View视图层。 vue生命周期总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后： 在beforeCreated阶段，vue实例的挂载元素el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。 在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定， 但是dom结构依然存在。 ajax请求最好放在created里面，因为此时已经可以访问this了，请求到数据就可以直接放在data里面。 关于dom的操作要放在mounted里面，在mounted前面访问dom会是undefined。 每次进入/离开组件都要做一些事情，用什么钩子： 不缓存： 进入的时候可以用created和mounted钩子，离开的时候用beforeDestory和destroyed钩子, beforeDestory可以访问this，destroyed不可以访问this。 缓存了组件： 缓存了组件之后，再次进入组件不会触发beforeCreate、created 、beforeMount、 mounted， 如果你想每次进入组件都做一些事情的话，你可以放在activated进入缓存组件的钩子中。 同理：离开缓存组件的时候，beforeDestroy和destroyed并不会触发，可以使用deactivated离开缓存组件的钩子来代替。 vue的双向数据绑定vue.js 是采用数据劫持结合发布者-订阅者模式的方式， 通过Object.defineProperty()来劫持各个属性的setter，getter， 在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter。 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图， 并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者， 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令， 最终利用Watcher搭起Observer和Compile之间的通信桥梁， 达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。 keep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 prop: include: 字符串或正则表达式。只有匹配的组件会被缓存。 exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存。 结合router，缓存部分页面 使用$route.meta的keepAlive属性 需要在router中设置router的元信息meta meta: { keepAlive: false // 不需要缓存 } v-model实现双向绑定，指令 &lt;input v-model=&quot;searchText&quot;&gt; 等价于 &lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; ###vuex vue框架中状态管理 State:单一状态树 Getter:getters 可以对State进行计算操作，它就是Store的计算属性 Mutation:类似于事件,mutation 必须是同步函数 Action:Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 Module:每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块 Vue.js中ajax请求代码应该写在组件的methods中还是vuex的actions中？一、如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用， 就不需要放入vuex 的state里。 二、如果被其他地方复用，这个很大几率上是需要的， 如果需要，请将请求放入action里，方便复用，并包装成promise返回， 在调用处用async await处理返回的数据。如果不要复用这个请求，那么直接写在vue文件里很方便。 每个周期具体适合哪些场景？生命周期钩子的一些使用方法： beforecreate : 可以在这加个loading事件，在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作dom axios的特点有哪些？一、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API 二、它可以拦截请求和响应 三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据 watch computed computed是基于它的依赖进⾏缓存的。computed只有在它的相关依赖发⽣变化才会重新 计算求值 watch 当需要在数据变化时执⾏异步","link":"/2018/09/13/vue/"},{"title":"微信小程序github可视化","text":"前言一直想做一些数据可视化的东西，所以就尝试在微信小程序中获取用户的一些GitHub上的数据以后，使用wx-charts来进行开发，GitHub的api可参考GitHubApi，目前只是获取了数据暂时展示了一下，样式请忽略😁，项目持续更新。 完成暂时完成了：18/09/06 following follows repositories和starts 仓库的语言类型 18/09/07 返回重输 输入为空和成功的优化 点击跟随人跳转进相应人信息 点击环形图弹出对应信息预览 git地址 所用wx-charts：去这里直接复制到你的项目随便哪里，在需要引用的地方 var wxCharts = require('../../utils/wxcharts.js'); ，例子都在他官网,需要下载到小程序中看效果，这里就展示一个饼图的基本代码：index.wxml:123&lt;view&gt; &lt;canvas canvas-id=&quot;pieCanvas&quot; class=&quot;canvas&quot; style=&quot;height:300px;width:100%;&quot;&gt;&lt;/canvas&gt;&lt;/view&gt; index.js12345678910111213141516171819202122232425var windowWidth = 320;try { var res = wx.getSystemInfoSync(); windowWidth = res.windowWidth;} catch (e) { console.error(&apos;getSystemInfoSync failed!&apos;);}new wxCharts({ animation: true, canvasId: &apos;pieCanvas&apos;, type: &apos;pie&apos;, series: [{ name: &apos;javascript&apos;, data: 3 }, { name: &apos;java&apos;, data: 1 }, { name: &apos;vue&apos;, data: 6 }], width: windowWidth, height: 300, dataLabel: true,}) 效果：GitHubApi：这里别人总结的github的api的一些用法，感谢！（api的请求次数有限制，如果自己在开发时需要经常请求，可以把一次请求的数据暂时存起来）weui-wexx：去这里直接复制到你的项目根目录下取名weui.wxss，然后在app.wxss中 @import 'weui.wxss'就好了，具体使用还是要去看他的官网","link":"/2018/09/07/微信小程序github可视化/"},{"title":"taro仿网易云音乐-小程序版","text":"前言前段时间用mpvue开发过一个仿网易云音乐的微信小程序(链接)，但似乎mpvue好像是不再维护了，偶然得知有个Taro也可以开发小程序，但是用的是React，正好也想了解了解React,所以体验了一下Taro。git地址 体验版预览· 18/12/28 歌单详情页面· 18/12/30 播放页面1.0(还没加入歌词)· 19/01/02 播放页面2.0· 19/01/03 个人页面· 19/01/03 每日推荐· 19/01/04 热门歌单、精品歌单 Taro简介Taro 是一套遵循 React 语法规范的 多端开发 解决方案。使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、RN 等）运行的代码，组件可以使用Taro的Taro-ui。(摘至官网) Taro-uiTaro-ui是一款基于 Taro 框架开发的多端 UI 组件库,里面的一些组件还是挺好用的，也挺好看的，官网很详细而且还有效果图提供观看和体验。 ReactReact的话跟着官网走一遍基本就能开发了，看了react以后还是觉得自己喜欢vue多一点(😂) 项目流程123npm install -g @tarojs/clitaro init myAppnpm run dev:weapp 开发小程序注意事项（摘自官网）若使用 微信小程序预览模式 ，则需下载并使用微信开发者工具添加项目进行预览，此时需要注意微信开发者工具的项目设置 需要设置关闭 ES6 转 ES5 功能，开启可能报错 需要设置关闭上传代码时样式自动补全，开启可能报错 需要设置关闭代码压缩上传，开启可能报错还有一些其他问题需要注意的，这里基本都指出了，我在实际开发中好像也没遇到过里面提及过的问题(😂) 开发相关 app.js对应的就是小程序的app.json一些基本配置可以在这里完成，比如tarBar 12345678910111213141516&quot;tabBar&quot;: { &quot;list&quot;: [ { &quot;text&quot;: &quot;音乐&quot;, &quot;pagePath&quot;: &quot;pages/music/music&quot;, &quot;iconPath&quot;: &quot;./img/music.png&quot;, &quot;selectedIconPath&quot;: &quot;./img/music.png&quot; }, { &quot;text&quot;: &quot;电影&quot;, &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;./img/movie.png&quot;, &quot;selectedIconPath&quot;: &quot;./img/movie.png&quot; } ] } 路由和传值 123456//可使用Taro的Taro.navigateTo({url:&apos;/pages/some?tag=tags&apos;})//或者&lt;Navigator url=&quot;/pages/some?tag=tags&quot;&gt;更多&lt;/Navigator&gt;//获取时使用this.$router.params.tag 引用iconfont先去iconfont官网选择你想要的icon， 选择添加到你自己的项目复制上面的代码在浏览器里打开(前面记得加https:)，然后在自己的项目中src目录下新建一个icon.scss名字随意css也行，复制在浏览器打开以后的内容粘贴进去，最后在app.tsc中import ‘./icon.scss’使用&lt;Text class=&quot;iconfont icon-play-circle&quot;&gt;&lt;/Text&gt; 父子组件 在其他地方写好子组件后，父组件内直接 import就行，传值的话直接在引用子组件时写入需要传递的数据即可 123&lt;Child dataname={somedata} /&gt;//在子组件中使用this.props.dataname即可获取传递过来的数据 获取setState以后的值 在开发过程中发现不能直接获取setState以后的值，因为 this.state 和 props 一定是异步更新的，所以不能在 setState 后马上拿到 state 的值，正确做法是 12345this.setState({ somedata: 1}, () =&gt; { // 在这个函数内你可以拿到 setState 之后的值})","link":"/2018/12/10/Trao开发微信小程序/"},{"title":"some-tips","text":"一些知识 TCP/IP（互联网相关的各类协议族的总称）协议族按层次分别分为以下 4 层： 应用层、传输层、网络层和数据链路层。 1. IP(网际协议，位于网络层) 负责传输 将各种数据包传输给对方，为了确保数据确实的传送，需要满足各类条件，其中两个重要的条件就是IP地址和MAC( Media Access Control)地址 IP地址指明了节点被分配的地址，MAC地址是指网卡所属于的固定地址。 IP间的通信依赖MAC地址，在通信过程中会使用ARP协议( Address Resolution Protocol 一种用以解析地址的协议) 根据通信方的IP地址反查出对应的MAC地址 2.TCP(位于传输层) 确保可靠性 TCP提供可靠的字节流服务，将大块数据分割成以报文段为单位的数据包。 TCP 协议采用了三次握手（ three-way handshaking ）策略： （1）发送端首先发送一个带 SYN 标志的数据包给对方。 （2）接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。 （3）最后，发送端再回传一个带 ACK 标志的数据包，代表 “ 握手 ” 结束。 3. DNS服务(位于应用层) 负责域名解析 在平时访问过程中，一般都是通过使用主机名或域名进行访问，而不是通过IP地址直接访问，但要让计算机去理解名称，就变得困难了。 为了解决上述的问题， DNS 服务应运而生。 DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名 URI和URL：URI 统一资源标识符,由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名 称。 URL 统一资源定位符,表示资源的地点（互联网上所处的位置） URL 是 URI 的子集 HTTP：用于客户端和服务器，通过请求响应达成通信： 请求报文是由请求方法、请求 URI 、协议版本、可选的请求首部字段和内容实体构成的。 GET /index.htm HTTP/1.1 请求访问某台服务器上/index.html的页面资源 HTTP/1.1 200 OK Date: Tue, 10 Jul 2012 06:50:15 GMT Content-Length: 362 Content-Type: text/html &lt;html&gt; …… 响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可 选的响应首部字段以及实体主体构成。 HTTP 协议自身不具备保存之前发送过的请求或响应的功能优点：由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。 使用Cookie状态管理： Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie 。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务 器上的记录，最后得到之前的状态信息。 HTTP协议使用 URI 定位互联网上的资源。 持久连接节省通信量：HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接，为解决TCP 连接的问题， HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接（ HTTP PersistentConnections ，也称为 HTTP keep-alive 或 HTTP connection reuse ）的方法。持久连接的特点是，只要任意 一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立 1 次 TCP 连接后进行多次请求和响应的交互 HTTP的几种请求方法用途 1、GET方法 发送一个请求来取得服务器上的某一资源 2、POST方法 向URL指定的资源提交数据或附加新的数据 3、PUT方法 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有 4、HEAD方法 只请求页面的首部 5、DELETE方法 删除服务器上的某资源 6、OPTIONS方法 它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息 7、TRACE方法 TRACE方法被用于激发一个远程的，应用层的请求消息回路 8、CONNECT方法 把请求连接转换到透明的TCP/IP通道 HTTP状态码及其含义1XX：信息状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 2XX：成功状态码 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 3XX：重定向 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 4XX：客户端错误 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 5XX: 服务器错误 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 typeof nulljs第一版中，数值以32字节存储，由标志位（1~3字节）和数值组成，不同的对象在底层都表示为二进制， null的二进制全是0，所以typeof null结果为object。 1. 000：对象，数据是对象的应用。 2. 1：整型，数据是31位带符号整数。 3. 010：双精度类型，数据是双精度数字。 4. 100：字符串，数据是字符串。 5. 110：布尔类型，数据是布尔值。 undefined 是一个没有设置值的变量。 typeof 一个没有值的变量会返回 undefined。 null 和 undefined 的值相等，但类型不等 闭包：闭包在 JavaScript 中常用来实现对象数据的私有 什么是闭包？ 简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。 闭包让我们能够从一个函数内部访问其外部函数的作用域。 要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。 HTTP工作原理一次HTTP操作称为一个事务，其工作整个过程如下： 1. 地址解析 如用客户端浏览器请求这个页面：#3 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： 协议名：https 主机名：github.com 端口：&apos;&apos; 对象路径：/web/blog/a 在这一步，需要域名系统DNS解析域名github.com，得主机的IP地址。 2. 封装HTTP请求数据包 把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 3. 封装成TCP包，建立TCP连接（TCP的三次握手） 在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。 TCP的三次握手 (1) 主机向服务器发送一个建立连接的请求； (2) 服务器接到请求后发送同意连接的信号；(为了防止已失效的连接请求报文段传至服务器导致错误) (3) 主机接到同意连接的信号后，再次向服务器发送了确认信号 ; 4. 客户机发送请求命令 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和内容。 5. 服务器响应 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 6. 服务器关闭TCP连接 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这个请求头Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 断开连接(TCP的四次挥手) (1) 主机向服务器发送一个断开连接的请求； (2) 服务器接到请求后发送确认收到请求的信号；(此时服务器可能还有数据要发送至主机) (3) 服务器向主机发送断开通知；(此时服务器确认没有要向主机发送的数据) (4) 主机接到断开通知后断开连接并反馈一个确认信号，服务器收到确认信号后断开连接； 浏览器从输入url到加载完成 都发生了什么1、浏览器地址栏输入url 2、浏览器会先查看浏览器缓存–系统缓存–路由缓存，如有存在缓存，就直接显示。如果没有，接着第三步 3、域名解析（DNS）获取相应的ip 4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手 5、握手成功，浏览器向服务器发送http请求，请求数据包 6、服务器请求数据，将数据返回到浏览器 7、浏览器接收响应，读取页面内容，解析html源码，生成DOM树 8、解析css样式、浏览器渲染，js交互 SSL工作原理SSL(Server socket layer) 是一种保证网络两个节点进行安全通信的协议。SSL和TLS建立在TCP/IP协议基础上。建立在SSL上的HTTP协议称为HTTPS，默认端口443。SSL使用加密技术实现会话双方信息的安全传递。 SSL加密类型 有两种基本的加解密算法类型： 1. 对称加密 密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES，RC5，3DES等；对称加密主要问题是共享秘钥，除你的计算机（客户端）知道另外一台计算机（服务器）的私钥秘钥，否则无法对通信流进行加密解密。 2. 非对称加密 使用两个秘钥：公共秘钥和私有秘钥。私有秘钥由一方密码保存（一般是服务器保存），另一方任何人都可以获得公共秘钥。 获取证书（经过CA认证过的公钥）有两种方式 1. 从权威机制购买证书。 安全证书由国际权威的证书机构(CA)，如VeriSign和Thawte颁发，它们保证了证书的可信性。一个安全证书只对一个IP有效，多个IP必需购买多个证书。 2. 创建自我签名的证书。 如果通信双方只关心数据在网络上的可以安全传输，并不需要对方进行身份验证，这种情况下，可以创建自多签名证书。这证书达不到身份认证的目的，但可以用于加密通信。 SSL握手 SSL 连接总是由客户端启动的。在SSL 会话开始时执行 SSL 握手。此握手产生会话的密码参数。关于如何处理 SSL 握手的简单概述，如下图所示。此示例假设已在 Web 浏览器 和 Web 服务器间建立了 SSL 连接。 html5有哪些新特性、移除了那些元素新特性: （1）语意化更好的内容元素，比如 article、footer、header、nav、section，表单控件，calendar、date、time、email、url、search; （2）一些功能标签，如绘画 canvas，用于媒介播放的 video 和 audio 元素; （3）本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;sessionStorage 的数据在浏览器关闭后自动删除; （4）新的技术，如webworker, websocket, Geolocation; **移除的元素：** （1）纯表现的元素：basefont，big，center，font, s，strike，tt，u; （2）对可用性产生负面影响的元素：frame，frameset，noframes； cookies，session,sessionStroage和localStorage的区别： cookies，sessionStroage和localStorage是在客户端，session是在服务器端。服务器端的session机制， session 对象数据保存在服务器上。 实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。服务器session存储数据安全一些，一般存放用户信息，浏览器只适合存储一般数据 其次，是**cookies，sessionStroage和localStorage三者的区别**： （1）cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存（2）存储大小限制也不同，cookie数据不能超过4k，同时因为每次Http请求都会携带cookie（这里可能还会追问，cookie是在http报文什么地方，答:cookie是携带在http请求头上的），所以cookie只适合保存很小的数据，比如会话标识sessionStroage和localstroage虽然也有大小限制，但是比cookie大很多，可以达到5M； （3） 数据有效期也不同，cookie在设置的有效期（服务端设置）内有效，不管窗口或者浏览器是否关闭，sessionStroage仅在当前浏览器窗口关闭前有效（也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁）；localStroage始终有效，窗口或者浏览器关闭也一直保存； （4） Web storage 支持事件通知机制，可以将数据更新的通知发送给监听者。如下： `window.addEventListener(&quot;storage&quot;, function (e) {` `alert(e.newValue);` `});` Web Storage带来的好处： 减少网络流量：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。 快速显示数据：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。 前端页面优化1.http请求优化 (1)减少HTTP请求 * 压缩合并js、css文件，可配置webpack使其合并成一个唯一出口文件 * 延迟加载 * 雪碧图CSS Sprite 一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位 来显示需要显示的图片部分。 (2)预加载 预先判断需要加载的数据，达到指定条件以后直接从浏览器缓存中获取 2.页面/性能优化 (1)引用优化 *css放在head标签内，js文件放在body标签的最下面 *css文件是异步加载的，浏览器在构建dom树的同时如果有对应的样式就直接显示出来，这样会让样式更早的出现 *js文件在下载时会阻塞dom树构建，只有js下载完成后才回继续构建下面的dom树，将js文件的引用放在最下面可在视觉上 减少白屏的出现 (2)将js动画替换成css动画 js继承1.原型链继承:直接让子类的prototype属性指向父类的实例,这样在子类的原型上拥有了父类的私有和公有属性. 2.借用构造函数(经典继承):在子类的构造函数中使用父类.call(this)方法,在构造新的子类实例的时候其实也执行了父类的 初始化代码,并且改变了this指向,这样子类就可以使用父类的私有属性了 3.原型式继承Object.create():create函数内部创建了一个临时的中间类,让这个类的原型等于传进来的原型对象,最后返回 了这个中间类的实例,让子类的prototype属性等于返回的实例,这样就拿到了父类的公有方法. 水平垂直居中1、定位 盒子宽高已知， position: absolute; left: 50%; top: 50%; margin-left:-自身一半宽度; margin-top: -自身一半高度; 2、table-cell布局 父级 display: table-cell; vertical-align: middle; 子级 margin: 0 auto; 3、定位 + transform ; 适用于 子盒子 宽高不定时； position: relative / absolute; /*top和left偏移各为50%*/ top: 50%; left: 50%; /*translate(-50%,-50%) 偏移自身的宽和高的-50%*/ transform: translate(-50%, -50%); 4、flex 布局 父级： /*flex 布局*/ display: flex; /*实现垂直居中*/ align-items: center; /*实现水平居中*/ justify-content: center; 跨域解决方案1.jsonp 动态创建script标签，请求一个带参网址并指定回调函数 缺点：只能实现get一种请求。 原生实现： &lt;script&gt; var script = doucment.createElement(&apos;script&apos;); script.src=&quot;http://www.asdf.com/?callback=abackfunction&quot;; function abackfunction(data){ 数据处理； } document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; 发起端定义jsonp的回调处理。 发起端做jsonp跨域请求 响应端使用发起端的同名函数处理跨域请求 2.CORS 浏览器对跨域请求区分为“简单请求”与“非简单请求” “简单请求”满足以下特征： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type： application/x-www-form-urlencoded、 multipart/form-data、text/plain 简单请求 只需要CORS服务端在接受到携带Origin字段的跨域请求后，在response header中添加Access-Control-Allow-Origin等字段给浏览器做同源判断。 非简单请求 需要CORS服务端对OPTIONS类型的请求做处理，其他与简单请求一致 3.nginx代理跨域 https简单概括HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。 减少reflow/repaint1）不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。 // bad var left = 10, top = 10; el.style.left = left + &quot;px&quot;; el.style.top = top + &quot;px&quot;; // Good el.className += &quot; theclassname&quot;; // Good el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;; 2）把DOM离线后修改。如： 使用documentFragment 对象在内存里操作DOM 先把DOM给display:none(有一次reflow)，然后你想怎么改就怎么改。比如修改100次，然后再把他显示出来。 clone一个DOM结点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。 3）不要把DOM结点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。 4）尽可能的修改层级比较低的DOM。当然，改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。 5）为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。","link":"/2018/09/03/some-tips/"},{"title":"个人简历","text":"汪志强23岁 | 男 | 本科 | 1年经验手机：15179816883 | 邮箱：1250407177@qq.com 个人优势用vue-cli+iview开发同伦评估系统前端，用微信小程序模拟网易云音乐（完善中）,现阶段实现热门歌曲、歌单、电台的展示；歌单详情、歌单评论、音乐播放功能,参与多个使用JAVA+SpringBoot+MyBatis+Mysql，jQuery+bootstrap的项目并进行运维，熟练使用 MySQL 数据库,本人对技术学习热情很高，喜欢探究各类技术。 期望职位web前端 杭州 8k-9k 计算机软件 工作经历南京同伦拍拍科技有限公司web前端 | 技术部 2017.07—2018.071 使用vue-cli+iview/angular 开发同伦智能评估前端2 维护项目上线3 使用java+springboot+MyBatis+mysql进行同伦管理后台、同伦crm,同伦拍辅app端后台接口和前端页面的开发 北京用友实习生 | 军工事业部 2016.07—2017.05用用友封装好的组件开发它的ERP系统，语言主要还是java,数据库用的oracle 项目经历mpvue+iview开发微信小程序角色：总体开发 时间：2018.08—至今使用mpvue+iview-weapp开发微信小程序（完善中）写了该项目的文章在掘金 https://juejin.im/post/5b88a6f36fb9a019f1801b8dgit的地址 https://github.com/Izayawww/my-project目前已完成页面 推荐，推荐歌单列表，搜索，用户信息,排行榜,播放页面，歌单评论，扫一扫(基础功能)，周边(百度地图api)预览： vue开发音乐播放器角色：总体开发 时间：2018.07—至今项目描述：通过使用Vue 全家桶项目开发音乐播放器，让自己更熟练的使用 Vue开发、ES6 等等知识。技术栈：vue+muse-ui+axios+vuex+vue-router数据来源:网易云音乐 NodeJS 版 API NeteaseCloudMusicApi目前实现了：首页，用户歌单，侧边栏，推荐，歌单详情，音乐播放，歌单评论，排行榜，MV推荐，电台等功能访问地址 http://lucasawww.coding.me/my-music/dist建议用chrome浏览器手机调试页面浏览大部分地方只要获取到数据，处理一下就能展示，最关键的还是在与音乐播放，音乐播放用的是HTML5 的 audio 实现，歌词方面用的是第三方库 lyric-parser和better-scroll 进行处理，显示歌词、拖动进度条歌词同步滚动、歌词跟随歌曲进度高亮预览： 同伦智能评估角色：前端页面开发 时间：2018.07—2018.07该项目是公司为了在线上对标的物进行评估。技术栈：vue+iview+axios+vue-router该项目是公司为了在线上对标的物进行评估。这个项目是由我个人开发的一个项目，从搭建到开发到上线，刚上手的时候是我们前端用angular搭建了一个框架，后来按照这个框架开发了一个版本，因为自己是用vue的，所以在征得同意以后我自己用vue重新开发了一个版本。 同伦crm角色：后台接口开发和发布 时间：2018.05—2018.06该项目是为了给公司内部的客户经理管理客户关系使用。该项目中我主要开发了 1.审核模块、2.公司模块、3.批量导入模块、4.即将公开客户模块审核模块主要是对整个项目流程进行控制，批量导入是将用户上传的Excel表中的数据进行多重判断以后批量导入数据库 同伦管理后台角色：后台开发，时间：前端开发 2017.07—2018.03该项目是用java+springboot+mybatis+mysql开发后台，jQuery+bootstrap开发前台，给同伦内部人员对标的物进行管理，并指派给各职务人员进行操作。我参与被分配的后台接口开发和前端界面开发，其中复杂点是报表的开发，需要联查10个表左右取数据在前端页面展示并导出Excel 教育经历东华理工大学软件工程 | 本科 2013—2017 社交主页个人博客 ：http://lucasswww.coding.me/Izayawww/ GitHub：https://github.com/Izayawww 掘金：https://juejin.im/user/59dc784c51882578d640993d","link":"/2018/09/03/个人简历/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"egg","slug":"egg","link":"/tags/egg/"},{"name":"小程序","slug":"小程序","link":"/tags/小程序/"},{"name":"知识","slug":"知识","link":"/tags/知识/"},{"name":"vue,rss","slug":"vue-rss","link":"/tags/vue-rss/"},{"name":"taro","slug":"taro","link":"/tags/taro/"},{"name":"简历","slug":"简历","link":"/tags/简历/"}],"categories":[{"name":"个人项目","slug":"个人项目","link":"/categories/个人项目/"},{"name":"知识","slug":"知识","link":"/categories/知识/"},{"name":"简历","slug":"简历","link":"/categories/简历/"}]}